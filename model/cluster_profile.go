package model

import (
	"context"
	"net/http"
	"os"
)

type ClusterProfile struct {

	// ID is a unique identifier for the cluster in the watcher application
	// cluster id will be generated by the server to avoid conflict
	ID string `json:"id"`

	// Name is a user-given name for the cluster
	// The Name will be unique in the application and is a required field
	// for cluster profile creation
	Name string `json:"name" validate:"required"`

	// Endpoints is a list of URLs of nodes
	// This is a required field for cluster profile creation
	Endpoints []string `json:"endpoints" validate:"required,gt=0,dive,required"`

	// Username is a user name for authentication.
	Username string `json:"username"`

	// Password is a password for authentication.
	Password string `json:"password"`

	// ServerName ensures the cert matches the given host in case of discovery / virtual hosting
	ServerName string `json:"server_name"`

	CreatedAt int64  `json:"created_at"`
	TLS       bool   `json:"tls"`
	CAFile    string `json:"ca_file"`
	CertFile  string `json:"cert_file"`
	KeyFile   string `json:"key_file"`
}

type ClusterProfileRepo interface {
	Create(context.Context, *ClusterProfile) error
	FetchByID(context.Context, string) (*ClusterProfile, error)
	FetchAll(context.Context) ([]*ClusterProfile, error)
}

type ClusterProfileService interface {
	Create(context.Context, *ClusterProfile) (*ClusterProfile, error)
	FetchByID(context.Context, string) (*ClusterProfile, error)
	FetchAll(context.Context) ([]*ClusterProfile, error)
	UploadCertificate(context.Context, *http.Request) (map[string]string, error)
}

type ClusterProfileController interface {
	Create() http.HandlerFunc
	Fetch() http.HandlerFunc
	UploadCertificate() http.HandlerFunc
}

func (*ClusterProfile) Prefix() string {
	return os.Getenv("CLUSTER_PREFIX")
}
